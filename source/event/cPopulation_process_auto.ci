///// exit /////

/**
* Ends the Avida run immediately.
**/


class cPopulationEventexit : public cPopulationEvent {
private:
public:
  cPopulationEventexit(const cString & in_args):
   cPopulationEvent("exit", in_args) {
 (void)in_args; }
///// exit /////
  void Process(){
    cAvidaDriver_Base::main_driver->SetDone();
  }
};

///// exit_if_generation_greater_than /////

/**
* Ends the Avida run when the current generation exceeds the
* maximum generation given as parameter.
*
* Parameters:
* max generation (int)
*   The generation at which the run should be stopped.
**/


class cPopulationEventexit_if_generation_greater_than : public cPopulationEvent {
private:
  int max_generation;
public:
  cPopulationEventexit_if_generation_greater_than(const cString & in_args):
   cPopulationEvent("exit_if_generation_greater_than", in_args) {

    cString args(in_args);
    max_generation = args.PopWord().AsInt();
  }
///// exit_if_generation_greater_than /////
  void Process(){
    if( population->GetGeneration() > max_generation ){
      cAvidaDriver_Base::main_driver->SetDone();
    }
  }
};

///// exit_if_update_greater_than /////

/**
* Ends the Avida run when the current update exceeds the
* maximum update given as parameter.
*
* Parameters:
* max update (int)
*   The update at which the run should be stopped.
**/


class cPopulationEventexit_if_update_greater_than : public cPopulationEvent {
private:
  int max_update;
public:
  cPopulationEventexit_if_update_greater_than(const cString & in_args):
   cPopulationEvent("exit_if_update_greater_than", in_args) {

    cString args(in_args);
    max_update = args.PopWord().AsInt();
  }
///// exit_if_update_greater_than /////
  void Process(){
    if( population->GetUpdate() > max_update ){
      cAvidaDriver_Base::main_driver->SetDone();
    }
  }
};

///// exit_if_ave_lineage_label_smaller /////

/**
* Halts the avida run if the current average lineage label is smaller
* than the value given as parameter.
*
* Parameters:
* lineage_label_crit_value (int)
*   The critical value to which the average lineage label is compared.
**/


class cPopulationEventexit_if_ave_lineage_label_smaller : public cPopulationEvent {
private:
  double lineage_label_crit_value;
public:
  cPopulationEventexit_if_ave_lineage_label_smaller(const cString & in_args):
   cPopulationEvent("exit_if_ave_lineage_label_smaller", in_args) {

    cString args(in_args);
    lineage_label_crit_value = args.PopWord().AsDouble();
  }
///// exit_if_ave_lineage_label_smaller /////
  void Process(){
    if( population->GetStats().GetAveLineageLabel() < lineage_label_crit_value ){
      cAvidaDriver_Base::main_driver->SetDone();
    }
  }
};

///// exit_if_ave_lineage_label_larger /////

/**
* Halts the avida run if the current average lineage label is larger
* than the value given as parameter.
*
* Parameters:
* lineage_label_crit_value (int)
*   The critical value to which the average lineage label is compared.
**/


class cPopulationEventexit_if_ave_lineage_label_larger : public cPopulationEvent {
private:
  double lineage_label_crit_value;
public:
  cPopulationEventexit_if_ave_lineage_label_larger(const cString & in_args):
   cPopulationEvent("exit_if_ave_lineage_label_larger", in_args) {

    cString args(in_args);
    lineage_label_crit_value = args.PopWord().AsDouble();
  }
///// exit_if_ave_lineage_label_larger /////
  void Process(){
    if( population->GetStats().GetAveLineageLabel() > lineage_label_crit_value ){
      cAvidaDriver_Base::main_driver->SetDone();
    }
  }
};

///// echo /////

/**
* Writes out a message. If no message is given, average update and
* generation are written out.
*
* Parameters:
* message (string)
**/


class cPopulationEventecho : public cPopulationEvent {
private:
  cString mesg;
public:
  cPopulationEventecho(const cString & in_args):
   cPopulationEvent("echo", in_args) {

    cString args(in_args);
    mesg = args.PopWord();
  }
///// echo /////
  void Process(){
    if( mesg == "" ){
       mesg.Set("Echo : Update = %f\t AveGeneration = %f",
    	     population->GetUpdate(), population->GetGeneration());
    }
    cAvidaDriver_Base::main_driver->NotifyComment(mesg);
  }
};

///// print_data /////

/**
* Output user-defined data from the cStats object...
*
* Parameters:
* filename (string)
*   The name of the data file.
* format
*   A comma-seperated list of statistics to output.
**/


class cPopulationEventprint_data : public cPopulationEvent {
private:
  cString filename;
  cString format;
public:
  cPopulationEventprint_data(const cString & in_args):
   cPopulationEvent("print_data", in_args) {

    cString args(in_args);
    filename = args.PopWord();
    format = args.PopWord();
  }
///// print_data /////
  void Process(){
    population->GetStats().PrintDataFile(filename, format, ',');
  }
};

///// print_average_data /////

/**
* Output various average quantities into datafile.
*
* Parameters:
* filename (string) default: average.dat
*   The name of the data file.
**/


class cPopulationEventprint_average_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_average_data(const cString & in_args):
   cPopulationEvent("print_average_data", in_args) {

    cString args(in_args);
    if (args == "") fname="average.dat"; else fname=args.PopWord();
  }
///// print_average_data /////
  void Process(){
    population->GetStats().PrintAverageData(fname);
  }
};

///// print_error_data /////

/**
* Prints out various data related to statistical errors.
*
* Parameters:
* filename (string) default: error.dat
*   The name of the data file.
**/


class cPopulationEventprint_error_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_error_data(const cString & in_args):
   cPopulationEvent("print_error_data", in_args) {

    cString args(in_args);
    if (args == "") fname="error.dat"; else fname=args.PopWord();
  }
///// print_error_data /////
  void Process(){
    population->GetStats().PrintErrorData(fname);
  }
};

///// print_variance_data /////

/**
* Prints out various variances.
*
* Parameters:
* filename (string) default: variance.dat
*   The name of the data file.
**/


class cPopulationEventprint_variance_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_variance_data(const cString & in_args):
   cPopulationEvent("print_variance_data", in_args) {

    cString args(in_args);
    if (args == "") fname="variance.dat"; else fname=args.PopWord();
  }
///// print_variance_data /////
  void Process(){
    population->GetStats().PrintVarianceData(fname);
  }
};

///// print_dominant_data /////

/**
* Output various quantities related to the dominant organism.
*
* Parameters:
* filename (string) default: dominant.dat
*   The name of the data file.
**/


class cPopulationEventprint_dominant_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_dominant_data(const cString & in_args):
   cPopulationEvent("print_dominant_data", in_args) {

    cString args(in_args);
    if (args == "") fname="dominant.dat"; else fname=args.PopWord();
  }
///// print_dominant_data /////
  void Process(){
    population->GetStats().PrintDominantData(fname);
  }
};

///// print_stats_data /////

/**
* Output various statistical quantities.
*
* Parameters:
* filename (string) default: stats.dat
*   The name of the data file.
**/


class cPopulationEventprint_stats_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_stats_data(const cString & in_args):
   cPopulationEvent("print_stats_data", in_args) {

    cString args(in_args);
    if (args == "") fname="stats.dat"; else fname=args.PopWord();
  }
///// print_stats_data /////
  void Process(){
    population->GetStats().PrintStatsData(fname);
  }
};

///// print_count_data /////

/**
* Output various counts, such as number of organisms etc.
*
* Parameters:
* filename (string) default: count.dat
*   The name of the data file.
**/


class cPopulationEventprint_count_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_count_data(const cString & in_args):
   cPopulationEvent("print_count_data", in_args) {

    cString args(in_args);
    if (args == "") fname="count.dat"; else fname=args.PopWord();
  }
///// print_count_data /////
  void Process(){
    population->GetStats().PrintCountData(fname);
  }
};

///// print_totals_data /////

/**
* Various total numbers.
*
* Parameters:
* filename (string) default: totals.dat
*   The name of the data file.
**/


class cPopulationEventprint_totals_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_totals_data(const cString & in_args):
   cPopulationEvent("print_totals_data", in_args) {

    cString args(in_args);
    if (args == "") fname="totals.dat"; else fname=args.PopWord();
  }
///// print_totals_data /////
  void Process(){
    population->GetStats().PrintTotalsData(fname);
  }
};

///// print_tasks_data /////

/**
* Output the number of times the various tasks have been performed in the
* last update.
*
* Parameters:
* filename (string) default: tasks.dat
*   The name of the data file.
**/


class cPopulationEventprint_tasks_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_tasks_data(const cString & in_args):
   cPopulationEvent("print_tasks_data", in_args) {

    cString args(in_args);
    if (args == "") fname="tasks.dat"; else fname=args.PopWord();
  }
///// print_tasks_data /////
  void Process(){
    population->GetStats().PrintTasksData(fname);
  }
};

///// print_tasks_exe_data /////

/**
**/


class cPopulationEventprint_tasks_exe_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_tasks_exe_data(const cString & in_args):
   cPopulationEvent("print_tasks_exe_data", in_args) {

    cString args(in_args);
    if (args == "") fname="tasks_exe.dat"; else fname=args.PopWord();
  }
///// print_tasks_exe_data /////
  void Process(){
    population->GetStats().PrintTasksExeData(fname);
  }
};

///// print_resource_data /////

/**
**/


class cPopulationEventprint_resource_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_resource_data(const cString & in_args):
   cPopulationEvent("print_resource_data", in_args) {

    cString args(in_args);
    if (args == "") fname="resource.dat"; else fname=args.PopWord();
  }
///// print_resource_data /////
  void Process(){
    population->GetStats().PrintResourceData(fname);
  }
};

///// print_time_data /////

/**
* Output time related data, such as update, generation, etc.
*
* Parameters:
* filename (string) default: time.dat
*   The name of the data file.
**/


class cPopulationEventprint_time_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_time_data(const cString & in_args):
   cPopulationEvent("print_time_data", in_args) {

    cString args(in_args);
    if (args == "") fname="time.dat"; else fname=args.PopWord();
  }
///// print_time_data /////
  void Process(){
    population->GetStats().PrintTimeData(fname);
  }
};

///// print_mutation_data /////

/**
**/


class cPopulationEventprint_mutation_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_mutation_data(const cString & in_args):
   cPopulationEvent("print_mutation_data", in_args) {

    cString args(in_args);
    if (args == "") fname="mutation.dat"; else fname=args.PopWord();
  }
///// print_mutation_data /////
  void Process(){
    population->GetStats().PrintMutationData(fname);
  }
};

///// print_mutation_rate_data /////

/**
Output (regular and log) statistics about individual copy
mutation rates (aver, stdev, skew, cur).
Useful only when mutation rate is set per organism.
**/


class cPopulationEventprint_mutation_rate_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_mutation_rate_data(const cString & in_args):
   cPopulationEvent("print_mutation_rate_data", in_args) {

    cString args(in_args);
    if (args == "") fname="mutation_rates.dat"; else fname=args.PopWord();
  }
///// print_mutation_rate_data /////
  void Process(){
    population->GetStats().PrintMutationRateData(fname);
  }
};

///// print_divide_mut_data /////

/**
Output (regular and log) statistics about individual, per site,
rates divide mutation rates (aver, stdev, skew, cur).
Use with multiple divide instuction set.
**/


class cPopulationEventprint_divide_mut_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_divide_mut_data(const cString & in_args):
   cPopulationEvent("print_divide_mut_data", in_args) {

    cString args(in_args);
    if (args == "") fname="divide_mut.dat"; else fname=args.PopWord();
  }
///// print_divide_mut_data /////
  void Process(){
    population->GetStats().PrintDivideMutData(fname);
  }
};

///// print_dom_parasite_data /////

/**
* Output various quantities related to the dominant parasite.
*
* Parameters:
* filename (string) default: parasite.dat
*   The name of the data file.
**/


class cPopulationEventprint_dom_parasite_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_dom_parasite_data(const cString & in_args):
   cPopulationEvent("print_dom_parasite_data", in_args) {

    cString args(in_args);
    if (args == "") fname="parasite.dat"; else fname=args.PopWord();
  }
///// print_dom_parasite_data /////
  void Process(){
    population->GetStats().PrintDominantParaData(fname);
  }
};

///// print_instruction_data /////

/**
Sum of the by-organisms counts of what instructions they _successfully_
execute beteween birth and divide. Prior to their first divide, organisms
report values for their parents.
**/


class cPopulationEventprint_instruction_data : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_instruction_data(const cString & in_args):
   cPopulationEvent("print_instruction_data", in_args) {

    cString args(in_args);
    if (args == "") fname="instruction.dat"; else fname=args.PopWord();
  }
///// print_instruction_data /////
  void Process(){
    population->GetStats().PrintInstructionData(fname);
  }
};

///// print_instruction_abundance_histogram /////

/**
*
* Appends a line containing the bulk count (abundance) of
* each instruction in the population onto a file.
* 
* Parameters:
* filename (string) default: "instruction_histogram.dat"
*
**/


class cPopulationEventprint_instruction_abundance_histogram : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventprint_instruction_abundance_histogram(const cString & in_args):
   cPopulationEvent("print_instruction_abundance_histogram", in_args) {

    cString args(in_args);
    if (args == "") filename="instruction_histogram.dat"; else filename=args.PopWord();
  }
///// print_instruction_abundance_histogram /////
  void Process(){
    ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
    cAnalyzeUtil::PrintInstructionAbundanceHistogram(fp, population);
  }
};

///// print_depth_histogram /////

/**
**/


class cPopulationEventprint_depth_histogram : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventprint_depth_histogram(const cString & in_args):
   cPopulationEvent("print_depth_histogram", in_args) {

    cString args(in_args);
    if (args == "") filename="depth_histogram.dat"; else filename=args.PopWord();
  }
///// print_depth_histogram /////
  void Process(){
    ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
    cAnalyzeUtil::PrintDepthHistogram(fp, population);
  }
};

///// print_genotype_abundance_histogram /////

/**
* Writes out a genotype abundance histogram.
*
* Parameters:
* filename (string) default: genotype_abundance_histogram.dat
*   The name of the file into which the histogram is written.
**/


class cPopulationEventprint_genotype_abundance_histogram : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventprint_genotype_abundance_histogram(const cString & in_args):
   cPopulationEvent("print_genotype_abundance_histogram", in_args) {

    cString args(in_args);
    if (args == "") filename="genotype_abundance_histogram.dat"; else filename=args.PopWord();
  }
///// print_genotype_abundance_histogram /////
  void Process(){
    ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
    cAnalyzeUtil::PrintGenotypeAbundanceHistogram(fp, population);
  }
};

///// print_species_abundance_histogram /////

/**
* Writes out a species abundance histogram.
*
* Parameters:
* filename (string) default: species_abundance_histogram.dat
*   The name of the file into which the histogram is written.
**/


class cPopulationEventprint_species_abundance_histogram : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventprint_species_abundance_histogram(const cString & in_args):
   cPopulationEvent("print_species_abundance_histogram", in_args) {

    cString args(in_args);
    if (args == "") filename="species_abundance_histogram.dat"; else filename=args.PopWord();
  }
///// print_species_abundance_histogram /////
  void Process(){
    ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
    cAnalyzeUtil::PrintSpeciesAbundanceHistogram(fp, population);
  }
};

///// print_lineage_totals /////

/**
**/


class cPopulationEventprint_lineage_totals : public cPopulationEvent {
private:
  cString fname;
  int verbose;
public:
  cPopulationEventprint_lineage_totals(const cString & in_args):
   cPopulationEvent("print_lineage_totals", in_args) {

    cString args(in_args);
    if (args == "") fname="lineage_totals.dat"; else fname=args.PopWord();
    if (args == "") verbose=1; else verbose=args.PopWord().AsInt();
  }
///// print_lineage_totals /////
  void Process(){
    static bool msg_printed = false;
    if (population->GetLineageControl() == NULL) {
      if ( msg_printed == false ){
        ofstream & fp = population->GetStats().GetDataFileOFStream(fname);
        fp << "No lineage data available!" << endl;
        msg_printed = true;
      }
      return;
    }
    population->GetLineageControl()->PrintLineageTotals(fname, verbose);
  }
};

///// print_lineage_counts /////

/**
**/


class cPopulationEventprint_lineage_counts : public cPopulationEvent {
private:
  cString fname;
  int verbose;
public:
  cPopulationEventprint_lineage_counts(const cString & in_args):
   cPopulationEvent("print_lineage_counts", in_args) {

    cString args(in_args);
    if (args == "") fname="lineage_counts.dat"; else fname=args.PopWord();
    if (args == "") verbose=0; else verbose=args.PopWord().AsInt();
  }
///// print_lineage_counts /////
  void Process(){
    static bool msg_printed = false;
    if (population->GetLineageControl() == NULL) {
      if ( msg_printed == false ){
        ofstream & fp = population->GetStats().GetDataFileOFStream(fname);
        fp << "No lineage data available!" << endl;
        msg_printed = true;
      }
      return;
    }
    if (verbose) {    // verbose mode is the same in both methods
      population->GetLineageControl()->PrintLineageTotals(fname, verbose);
      return;
    }
    population->GetLineageControl()->PrintLineageCurCounts(fname);
  }
};

///// print_dom /////

/**
* Write the currently dominant genotype to disk.
*
* Parameters:
* filename (string)
*   The name under which the genotype should be saved. If no
*   filename is given, the genotype is saved into the directory
*   genebank, under the name that the genebank has associated with
*   this genotype.
**/


class cPopulationEventprint_dom : public cPopulationEvent {
private:
  cString in_filename;
public:
  cPopulationEventprint_dom(const cString & in_args):
   cPopulationEvent("print_dom", in_args) {

    cString args(in_args);
    if (args == "") in_filename=""; else in_filename=args.PopWord();
  }
///// print_dom /////
  void Process(){
    cGenotype * dom = population->GetGenebank().GetBestGenotype();
    cString filename(in_filename);
    if (filename == "") filename.Set("genebank/%s", dom->GetName()());
    cTestUtil::PrintGenome(dom->GetGenome(), filename, dom, population->GetUpdate()); 
  }
};

///// parasite_debug /////

//midget


class cPopulationEventparasite_debug : public cPopulationEvent {
private:
  cString in_filename;
public:
  cPopulationEventparasite_debug(const cString & in_args):
   cPopulationEvent("parasite_debug", in_args) {

    cString args(in_args);
    if (args == "") in_filename=""; else in_filename=args.PopWord();
  }
///// parasite_debug /////
  void Process(){
    population->ParasiteDebug();
  }
};

///// print_dom_parasite /////

/**
* Write the currently dominant injected genotype to disk.
*
* Parameters:
* filename (string)
*   The name under which the genotype should be saved. If no
*   filename is given, the genotype is saved into the directory
*   genebank, under the name that the genebank has associated with
*   this genotype.
**/


class cPopulationEventprint_dom_parasite : public cPopulationEvent {
private:
  cString in_filename;
public:
  cPopulationEventprint_dom_parasite(const cString & in_args):
   cPopulationEvent("print_dom_parasite", in_args) {

    cString args(in_args);
    if (args == "") in_filename=""; else in_filename=args.PopWord();
  }
///// print_dom_parasite /////
  void Process(){
    cInjectGenotype * dom = population->GetInjectGenebank().GetBestInjectGenotype();
    if (dom!=NULL) {
    cString filename(in_filename);
    if (filename == "") filename.Set("genebank/%s", dom->GetName()());
    cTestUtil::PrintGenome(dom, dom->GetGenome(), filename, population->GetUpdate()); }
  }
};

///// print_genotype_map /////

/**
* write a matrix of genotype ID's to a file (matlab format)
**/


class cPopulationEventprint_genotype_map : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_genotype_map(const cString & in_args):
   cPopulationEvent("print_genotype_map", in_args) {

    cString args(in_args);
    if (args == "") fname="genotype_map.m"; else fname=args.PopWord();
  }
///// print_genotype_map /////
  void Process(){
    population->GetStats().PrintGenotypeMap(fname);
  }
};

///// print_number_phenotypes /////

/**
Output file with number of phenotypes based on tasks executed
for this update.  Executing a task any numbers of times is considered
the same as executing it once. 
**/


class cPopulationEventprint_number_phenotypes : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventprint_number_phenotypes(const cString & in_args):
   cPopulationEvent("print_number_phenotypes", in_args) {

    cString args(in_args);
    if (args == "") fname="phenotype_count.dat"; else fname=args.PopWord();
  }
///// print_number_phenotypes /////
  void Process(){
    population->PrintPhenotypeData(fname);
  }
};

///// save_population /////

/**
* Saves the full state of the population.
*
* Parameters:
* filename (string) default: save_pop.*
*   The name of the file into which the population should
*   be saved. If it is not given, then the name 'save_pop.*'
*   is used, with '*' replaced by the current update.
**/


class cPopulationEventsave_population : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventsave_population(const cString & in_args):
   cPopulationEvent("save_population", in_args) {

    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
///// save_population /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("save_pop.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->SavePopulation(fp);
  }
};

///// load_population /////

/**
* Loads the full state of the population.
*
* Parameters:
* filename (string)
*   The name of the file to open.
**/


class cPopulationEventload_population : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventload_population(const cString & in_args):
   cPopulationEvent("load_population", in_args) {

    cString args(in_args);
    fname = args.PopWord();
  }
///// load_population /////
  void Process(){
    ifstream fp(fname());
    population->LoadPopulation(fp);
  }
};

///// save_clone /////

/**
**/


class cPopulationEventsave_clone : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventsave_clone(const cString & in_args):
   cPopulationEvent("save_clone", in_args) {

    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
///// save_clone /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("clone.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->SaveClone(fp);
  }
};

///// load_clone /////

/**
**/


class cPopulationEventload_clone : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventload_clone(const cString & in_args):
   cPopulationEvent("load_clone", in_args) {

    cString args(in_args);
    fname = args.PopWord();
  }
///// load_clone /////
  void Process(){
    ifstream fp(fname());
    population->LoadClone(fp);
  }
};

///// load_dump_file /////

/**
* Sets up a population based on a dump file such as written out by
* detail_pop. It is also possible to append a history file to the dump
* file, in order to preserve the history of a previous run.
**/


class cPopulationEventload_dump_file : public cPopulationEvent {
private:
  cString fname;
  int update;
public:
  cPopulationEventload_dump_file(const cString & in_args):
   cPopulationEvent("load_dump_file", in_args) {

    cString args(in_args);
    fname = args.PopWord();
    if (args == "") update=-1; else update=args.PopWord().AsInt();
  }
///// load_dump_file /////
  void Process(){
    population->LoadDumpFile(fname, update);
  }
};

///// dump_pop /////

/**
* Writes out a line of data for each genotype in the current population. The
* line contains the genome as string, the number of organisms of that genotype,
* and the genotype ID.
*
* Parameters:
* filename (string) default: "dump.<update>"
*   The name of the file into which the population dump should be written.
**/


class cPopulationEventdump_pop : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventdump_pop(const cString & in_args):
   cPopulationEvent("dump_pop", in_args) {

    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
///// dump_pop /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("dump.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->GetGenebank().DumpTextSummary(fp);
  }
};

///// detail_pop /////

/**
* Like dump_pop, but more detailed data is written out.
*
* Parameters:
* filename (string) default: "detail_pop.<update>"
*   The name of the file into which the population dump should be written.
**/


class cPopulationEventdetail_pop : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventdetail_pop(const cString & in_args):
   cPopulationEvent("detail_pop", in_args) {

    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
///// detail_pop /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("detail_pop.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->GetGenebank().DumpDetailedSummary(fp);
  }
};

///// detail_parasite_pop /////

/**
* Like dump_pop, but more detailed data is written out.
*
* Parameters:
* filename (string) default: "detail_pop.<update>"
*   The name of the file into which the population dump should be written.
**/


class cPopulationEventdetail_parasite_pop : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventdetail_parasite_pop(const cString & in_args):
   cPopulationEvent("detail_parasite_pop", in_args) {

    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
///// detail_parasite_pop /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("detail_parasite_pop.%d", population->GetUpdate());
    }
    //ofstream fp(filename());
    population->GetInjectGenebank().DumpDetailedSummary(filename, population->GetUpdate());
  }
};

///// dump_historic_pop /////

/**
* Similar to detail_pop. However, only genotypes that are not in the
* current population anymore are included. Genotypes that are not in
* the line of descent of any of the current genotypes to the ultimate
* ancestor are excluded.
*
* Parameters:
* filename (string) default: "historic_dump.<update>"
*   The name of the file into which the historic dump should be written.
**/


class cPopulationEventdump_historic_pop : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventdump_historic_pop(const cString & in_args):
   cPopulationEvent("dump_historic_pop", in_args) {

    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
///// dump_historic_pop /////
  void Process(){
    cString filename;
    if( fname == "" ){
      filename.Set("historic_dump.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->GetGenebank().DumpHistoricSummary(fp);
  }
};

///// dump_memory /////

/**
* Dump the current memory state of all CPUs to a file.
**/


class cPopulationEventdump_memory : public cPopulationEvent {
private:
  cString fname;
public:
  cPopulationEventdump_memory(const cString & in_args):
   cPopulationEvent("dump_memory", in_args) {

    cString args(in_args);
    if (args == "") fname=""; else fname=args.PopWord();
  }
///// dump_memory /////
  void Process(){
    cString filename;
    if (fname == "") {
      filename.Set("memory_dump.%d", population->GetUpdate());
    }
    ofstream fp(filename());
    population->DumpMemorySummary(fp);
  }
};

///// inject /////

/**
* Injects a single organism into the population.
*
* Parameters:
* filename (string)
*   The filename of the genotype to load. If this is left empty, or the keyword
*   "START_CREATURE" is given, than the genotype specified in the genesis
*   file under "START_CREATURE" is used.
* cell ID (integer) default: 0
*   The grid-point into which the organism should be placed.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
**/


class cPopulationEventinject : public cPopulationEvent {
private:
  cString fname;
  int cell_id;
  double merit;
  int lineage_label;
  double neutral_metric;
public:
  cPopulationEventinject(const cString & in_args):
   cPopulationEvent("inject", in_args) {

    cString args(in_args);
    if (args == "") fname="START_CREATURE"; else fname=args.PopWord();
    if (args == "") cell_id=0; else cell_id=args.PopWord().AsInt();
    if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
    if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
    if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
  }
///// inject /////
  void Process(){
    if (fname == "START_CREATURE") fname=cConfig::GetStartCreature();
    cGenome genome =
       cInstUtil::LoadGenome(fname, population->GetEnvironment().GetInstSet());
    population->Inject(genome, cell_id, merit, lineage_label, neutral_metric);
  }
};

///// inject_all /////

/**
* Injects identical organisms into all cells of the population.
*
* Parameters:
* filename (string)
*   The filename of the genotype to load. If this is left empty, or the keyword
*   "START_CREATURE" is given, than the genotype specified in the genesis
*   file under "START_CREATURE" is used.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
**/


class cPopulationEventinject_all : public cPopulationEvent {
private:
  cString fname;
  double merit;
  int lineage_label;
  double neutral_metric;
public:
  cPopulationEventinject_all(const cString & in_args):
   cPopulationEvent("inject_all", in_args) {

    cString args(in_args);
    if (args == "") fname="START_CREATURE"; else fname=args.PopWord();
    if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
    if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
    if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
  }
///// inject_all /////
  void Process(){
    if (fname == "START_CREATURE") fname=cConfig::GetStartCreature();
    cGenome genome =
       cInstUtil::LoadGenome(fname, population->GetEnvironment().GetInstSet());
    for (int i = 0; i < population->GetSize(); i++) {
      population->Inject(genome, i, merit, lineage_label, neutral_metric);
    }
    population->SetSyncEvents(true);
  }
};

///// inject_range /////

/**
* Injects identical organisms into a range of cells of the population.
*
* Parameters:
* filename (string)
*   The filename of the genotype to load. If this is left empty, or the keyword
*   "START_CREATURE" is given, than the genotype specified in the genesis
*   file under "START_CREATURE" is used.
* start_cell (int)
*   First cell to inject into.
* stop_cell (int)
*   First cell *not* to inject into.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
*
* Example:
*   inject_range creature.gen 0 10
*
* Will inject 10 organisms into cells 0 through 9.
**/


class cPopulationEventinject_range : public cPopulationEvent {
private:
  cString fname;
  int start_cell;
  int end_cell;
  double merit;
  int lineage_label;
  double neutral_metric;
public:
  cPopulationEventinject_range(const cString & in_args):
   cPopulationEvent("inject_range", in_args) {

    cString args(in_args);
    if (args == "") fname="START_CREATURE"; else fname=args.PopWord();
    if (args == "") start_cell=0; else start_cell=args.PopWord().AsInt();
    if (args == "") end_cell=-1; else end_cell=args.PopWord().AsInt();
    if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
    if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
    if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
  }
///// inject_range /////
  void Process(){
    if (fname == "START_CREATURE") fname=cConfig::GetStartCreature();
    if (end_cell == -1) end_cell = start_cell + 1;
    if (start_cell < 0 ||
        end_cell > population->GetSize() ||
        start_cell >= end_cell) {
      cout << "Warning: inject_range has invalid range!";
    }
    else {
      cGenome genome =
         cInstUtil::LoadGenome(fname, population->GetEnvironment().GetInstSet());
      for (int i = start_cell; i < end_cell; i++) {
        population->Inject(genome, i, merit, lineage_label, neutral_metric);
      }
      population->SetSyncEvents(true);
    }
  }
};

///// inject_sequence /////

/**
* Injects identical organisms into a range of cells of the population.
*
* Parameters:
* sequence (string)
*   The genome sequence for this organism.  This is a mandatory argument.
* start_cell (int)
*   First cell to inject into.
* stop_cell (int)
*   First cell *not* to inject into.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
*
* Example:
*   inject_range ckdfhgklsahnfsaggdsgajfg 0 10 100
*
* Will inject 10 organisms into cells 0 through 9 with a merit of 100.
**/


class cPopulationEventinject_sequence : public cPopulationEvent {
private:
  cString seq;
  int start_cell;
  int end_cell;
  double merit;
  int lineage_label;
  double neutral_metric;
public:
  cPopulationEventinject_sequence(const cString & in_args):
   cPopulationEvent("inject_sequence", in_args) {

    cString args(in_args);
    seq = args.PopWord();
    if (args == "") start_cell=0; else start_cell=args.PopWord().AsInt();
    if (args == "") end_cell=-1; else end_cell=args.PopWord().AsInt();
    if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
    if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
    if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
  }
///// inject_sequence /////
  void Process(){
    if (end_cell == -1) end_cell = start_cell + 1;
    if (start_cell < 0 ||
        end_cell > population->GetSize() ||
        start_cell >= end_cell) {
      cout << "Warning: inject_sequence has invalid range!";
    }
    else {
      cGenome genome(seq);
      for (int i = start_cell; i < end_cell; i++) {
        population->Inject(genome, i, merit, lineage_label, neutral_metric);
      }
      population->SetSyncEvents(true);
    }
  }
};

///// inject_random /////

/**
* Injects a randomly generated genome into the population.
*
* Parameters:
* length (integer) [required]
*   Number of instructions in the randomly generated genome.
* cell ID (integer) default: -1
*   The grid-point into which the genome should be placed.  Default is random.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
**/


class cPopulationEventinject_random : public cPopulationEvent {
private:
  int length;
  int cell_id;
  double merit;
  int lineage_label;
  double neutral_metric;
public:
  cPopulationEventinject_random(const cString & in_args):
   cPopulationEvent("inject_random", in_args) {

    cString args(in_args);
    length = args.PopWord().AsInt();
    if (args == "") cell_id=-1; else cell_id=args.PopWord().AsInt();
    if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
    if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
    if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
  }
///// inject_random /////
  void Process(){
    if (cell_id == -1) cell_id = g_random.GetUInt(population->GetSize());
    cGenome genome =
       cInstUtil::RandomGenome(length, population->GetEnvironment().GetInstSet());
    population->Inject(genome, cell_id, merit, lineage_label, neutral_metric);
  }
};

///// inject_range_parasite /////

/**
* Injects identical organisms into a range of cells of the population.
*
* Parameters:
* filename (string)
*   The filename of the genotype to load. If this is left empty, or the keyword
*   "START_CREATURE" is given, than the genotype specified in the genesis
*   file under "START_CREATURE" is used.
* start_cell (int)
*   First cell to inject into.
* stop_cell (int)
*   First cell *not* to inject into.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
*
* Example:
*   inject_range creature.gen 0 10
*
* Will inject 10 organisms into cells 0 through 9.
**/


class cPopulationEventinject_range_parasite : public cPopulationEvent {
private:
  cString fname_parasite;
  int start_cell;
  int end_cell;
  double merit;
  int lineage_label;
  double neutral_metric;
  int mem_space;
public:
  cPopulationEventinject_range_parasite(const cString & in_args):
   cPopulationEvent("inject_range_parasite", in_args) {

    cString args(in_args);
    if (args == "") fname_parasite="organism.parasite"; else fname_parasite=args.PopWord();
    if (args == "") start_cell=0; else start_cell=args.PopWord().AsInt();
    if (args == "") end_cell=-1; else end_cell=args.PopWord().AsInt();
    if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
    if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
    if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
    if (args == "") mem_space=2; else mem_space=args.PopWord().AsInt();
  }
///// inject_range_parasite /////
  void Process(){
    if (fname_parasite == "START_CREATURE") fname_parasite=cConfig::GetStartCreature();
    if (end_cell == -1) end_cell = start_cell + 1;
    if (start_cell < 0 ||
        end_cell > population->GetSize() ||
        start_cell >= end_cell) {
      cout << "Warning: inject_range has invalid range!";
    }
    else {
      cGenome genome_parasite =
         cInstUtil::LoadGenome(fname_parasite, population->GetEnvironment().GetInstSet());
      for (int i = start_cell; i < end_cell; i++) {
        population->Inject(genome_parasite, i, merit, lineage_label, neutral_metric, mem_space);
      }
      population->SetSyncEvents(true);
    }
  }
};

///// inject_range_pair /////

/**
* Injects identical organisms into a range of cells of the population.
*
* Parameters:
* filename (string)
*   The filename of the genotype to load. If this is left empty, or the keyword
*   "START_CREATURE" is given, than the genotype specified in the genesis
*   file under "START_CREATURE" is used.
* start_cell (int)
*   First cell to inject into.
* stop_cell (int)
*   First cell *not* to inject into.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
*
* Example:
*   inject_range creature.gen 0 10
*
* Will inject 10 organisms into cells 0 through 9.
**/


class cPopulationEventinject_range_pair : public cPopulationEvent {
private:
  cString fname;
  cString fname_parasite;
  int start_cell;
  int end_cell;
  double merit;
  int lineage_label;
  double neutral_metric;
  int mem_space;
public:
  cPopulationEventinject_range_pair(const cString & in_args):
   cPopulationEvent("inject_range_pair", in_args) {

    cString args(in_args);
    if (args == "") fname="START_CREATURE"; else fname=args.PopWord();
    if (args == "") fname_parasite="organism.parasite"; else fname_parasite=args.PopWord();
    if (args == "") start_cell=0; else start_cell=args.PopWord().AsInt();
    if (args == "") end_cell=-1; else end_cell=args.PopWord().AsInt();
    if (args == "") merit=-1; else merit=args.PopWord().AsDouble();
    if (args == "") lineage_label=0; else lineage_label=args.PopWord().AsInt();
    if (args == "") neutral_metric=0; else neutral_metric=args.PopWord().AsDouble();
    if (args == "") mem_space=2; else mem_space=args.PopWord().AsInt();
  }
///// inject_range_pair /////
  void Process(){
    if (fname == "START_CREATURE") fname=cConfig::GetStartCreature();
    if (end_cell == -1) end_cell = start_cell + 1;
    if (start_cell < 0 ||
        end_cell > population->GetSize() ||
        start_cell >= end_cell) {
      cout << "Warning: inject_range has invalid range!";
    }
    else {
      cGenome genome =
         cInstUtil::LoadGenome(fname, population->GetEnvironment().GetInstSet());
      cGenome genome_parasite =
         cInstUtil::LoadGenome(fname_parasite, population->GetEnvironment().GetInstSet());
      for (int i = start_cell; i < end_cell; i++) {
        population->Inject(genome, i, merit, lineage_label, neutral_metric);
        population->Inject(genome_parasite, i, merit, lineage_label, neutral_metric, mem_space);
      }
      population->SetSyncEvents(true);
    }
  }
};

///// zero_muts /////

/**
 * This event will set all mutation rates to zero...
 **/


class cPopulationEventzero_muts : public cPopulationEvent {
private:
public:
  cPopulationEventzero_muts(const cString & in_args):
   cPopulationEvent("zero_muts", in_args) {
 (void)in_args; }
///// zero_muts /////
  void Process(){
    for (int i = 0; i < population->GetSize(); i++) {
      population->GetCell(i).MutationRates().Clear();
    }
  }
};

///// mod_copy_mut /////

/**
**/


class cPopulationEventmod_copy_mut : public cPopulationEvent {
private:
  double cmut_inc;
  int cell;
public:
  cPopulationEventmod_copy_mut(const cString & in_args):
   cPopulationEvent("mod_copy_mut", in_args) {

    cString args(in_args);
    cmut_inc = args.PopWord().AsDouble();
    if (args == "") cell=-1; else cell=args.PopWord().AsInt();
  }
///// mod_copy_mut /////
  void Process(){
    const double new_cmut = cConfig::GetCopyMutProb() + cmut_inc;
    if (cell < 0) {   // cell == -1  -->  all
      for (int i = 0; i < population->GetSize(); i++) {
        population->GetCell(i).MutationRates().SetCopyMutProb(new_cmut);
      }
      cConfig::SetCopyMutProb(new_cmut);
    } else {
      population->GetCell(cell).MutationRates().SetCopyMutProb(new_cmut);
    }
  }
};

///// mod_div_mut /////

/**
**/


class cPopulationEventmod_div_mut : public cPopulationEvent {
private:
  double dmut_inc;
  int cell;
public:
  cPopulationEventmod_div_mut(const cString & in_args):
   cPopulationEvent("mod_div_mut", in_args) {

    cString args(in_args);
    dmut_inc = args.PopWord().AsDouble();
    if (args == "") cell=-1; else cell=args.PopWord().AsInt();
  }
///// mod_div_mut /////
  void Process(){
    const double new_div_mut = cConfig::GetDivMutProb() + dmut_inc;
    if (cell < 0) {   // cell == -1  -->  all
      for (int i = 0; i < population->GetSize(); i++) {
        population->GetCell(i).MutationRates().SetDivMutProb(new_div_mut);
      }
      cConfig::SetDivMutProb(new_div_mut);
    } else {
      population->GetCell(cell).MutationRates().SetDivMutProb(new_div_mut);
    }
  }
};

///// set_copy_mut /////

/**
**/


class cPopulationEventset_copy_mut : public cPopulationEvent {
private:
  double cmut;
  int start_cell;
  int end_cell;
public:
  cPopulationEventset_copy_mut(const cString & in_args):
   cPopulationEvent("set_copy_mut", in_args) {

    cString args(in_args);
    cmut = args.PopWord().AsDouble();
    if (args == "") start_cell=-1; else start_cell=args.PopWord().AsInt();
    if (args == "") end_cell=-1; else end_cell=args.PopWord().AsInt();
  }
///// set_copy_mut /////
  void Process(){
    if (start_cell < 0) {   // start_cell == -1  -->  all
      cConfig::SetCopyMutProb(cmut);
      start_cell = 0;
      end_cell = population->GetSize();
    }
    else if (end_cell < -1)  { // end_cell == -1 --> Only one cell!
      end_cell = start_cell + 1;
    }
    assert(start_cell >= 0 && start_cell < population->GetSize());
    assert(end_cell > 0 && end_cell <= population->GetSize());
    for (int i = start_cell; i < end_cell; i++) {
      population->GetCell(i).MutationRates().SetCopyMutProb(cmut);
    }
  }
};

///// mod_point_mut /////

/**
**/


class cPopulationEventmod_point_mut : public cPopulationEvent {
private:
  double pmut_inc;
  int cell;
public:
  cPopulationEventmod_point_mut(const cString & in_args):
   cPopulationEvent("mod_point_mut", in_args) {

    cString args(in_args);
    pmut_inc = args.PopWord().AsDouble();
    if (args == "") cell=-1; else cell=args.PopWord().AsInt();
  }
///// mod_point_mut /////
  void Process(){
    const double new_pmut = cConfig::GetPointMutProb() + pmut_inc;
    if (cell < 0) {   // cell == -1   -->  all
      for (int i = 0; i < population->GetSize(); i++) {
        population->GetCell(i).MutationRates().SetPointMutProb(new_pmut);
      }
      cConfig::SetPointMutProb(new_pmut);
    } else {
      population->GetCell(cell).MutationRates().SetPointMutProb(new_pmut);
    }
  }
};

///// set_point_mut /////

/**
**/


class cPopulationEventset_point_mut : public cPopulationEvent {
private:
  double pmut;
  int cell;
public:
  cPopulationEventset_point_mut(const cString & in_args):
   cPopulationEvent("set_point_mut", in_args) {

    cString args(in_args);
    pmut = args.PopWord().AsDouble();
    if (args == "") cell=-1; else cell=args.PopWord().AsInt();
  }
///// set_point_mut /////
  void Process(){
    if (cell < 0) {   // cell == -1   -->  all
      for (int i = 0; i < population->GetSize(); i++) {
        population->GetCell(i).MutationRates().SetPointMutProb(pmut);
      }
      cConfig::SetPointMutProb(pmut);
    } else {
      population->GetCell(cell).MutationRates().SetPointMutProb(pmut);
    }
  }
};

///// calc_landscape /////

/**
**/


class cPopulationEventcalc_landscape : public cPopulationEvent {
private:
  int landscape_dist;
public:
  cPopulationEventcalc_landscape(const cString & in_args):
   cPopulationEvent("calc_landscape", in_args) {

    cString args(in_args);
    if (args == "") landscape_dist=1; else landscape_dist=args.PopWord().AsInt();
  }
///// calc_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cAnalyzeUtil::CalcLandscape(landscape_dist, genome,
                                population->GetEnvironment().GetInstSet());
  }
};

///// predict_w_landscape /////

/**
**/


class cPopulationEventpredict_w_landscape : public cPopulationEvent {
private:
  cString datafile;
public:
  cPopulationEventpredict_w_landscape(const cString & in_args):
   cPopulationEvent("predict_w_landscape", in_args) {

    cString args(in_args);
    if (args == "") datafile="land-predict.dat"; else datafile=args.PopWord();
  }
///// predict_w_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    static ofstream fp(datafile);
    landscape.PredictWProcess(fp);
  }
};

///// predict_nu_landscape /////

/**
**/


class cPopulationEventpredict_nu_landscape : public cPopulationEvent {
private:
  cString datafile;
public:
  cPopulationEventpredict_nu_landscape(const cString & in_args):
   cPopulationEvent("predict_nu_landscape", in_args) {

    cString args(in_args);
    if (args == "") datafile="land-predict.dat"; else datafile=args.PopWord();
  }
///// predict_nu_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    static ofstream fp(datafile);
    landscape.PredictNuProcess(fp);
  }
};

///// sample_landscape /////

/**
**/


class cPopulationEventsample_landscape : public cPopulationEvent {
private:
  int sample_size;
public:
  cPopulationEventsample_landscape(const cString & in_args):
   cPopulationEvent("sample_landscape", in_args) {

    cString args(in_args);
    if (args == "") sample_size=0; else sample_size=args.PopWord().AsInt();
  }
///// sample_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    if (sample_size == 0) sample_size = population->GetEnvironment().GetInstSet().GetSize() - 1;
    landscape.SampleProcess(sample_size);
    static ofstream fp("land-sample.dat");
    landscape.PrintStats(fp, population->GetUpdate());
  }
};

///// random_landscape /////

/**
**/


class cPopulationEventrandom_landscape : public cPopulationEvent {
private:
  int landscape_dist;
  int sample_size;
  int min_found;
  int max_sample_size;
  bool print_if_found;
public:
  cPopulationEventrandom_landscape(const cString & in_args):
   cPopulationEvent("random_landscape", in_args) {

    cString args(in_args);
    if (args == "") landscape_dist=1; else landscape_dist=args.PopWord().AsInt();
    if (args == "") sample_size=0; else sample_size=args.PopWord().AsInt();
    if (args == "") min_found=0; else min_found=args.PopWord().AsInt();
    if (args == "") max_sample_size=0; else max_sample_size=args.PopWord().AsInt();
    if (args == "") print_if_found=false; else print_if_found=args.PopWord();
  }
///// random_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    landscape.RandomProcess(sample_size, landscape_dist, min_found,
                            max_sample_size, print_if_found);
    static ofstream fp("land-random.dat");
    landscape.PrintStats(fp, population->GetUpdate());
  }
};

///// analyze_landscape /////

/**
**/


class cPopulationEventanalyze_landscape : public cPopulationEvent {
private:
  int sample_size;
  int min_found;
  int max_sample_size;
public:
  cPopulationEventanalyze_landscape(const cString & in_args):
   cPopulationEvent("analyze_landscape", in_args) {

    cString args(in_args);
    if (args == "") sample_size=1000; else sample_size=args.PopWord().AsInt();
    if (args == "") min_found=0; else min_found=args.PopWord().AsInt();
    if (args == "") max_sample_size=0; else max_sample_size=args.PopWord().AsInt();
  }
///// analyze_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cAnalyzeUtil::
    AnalyzeLandscape(genome, population->GetEnvironment().GetInstSet(),
     		 sample_size, min_found, max_sample_size,
    		 population->GetUpdate());
  }
};

///// pairtest_landscape /////

/**
* If sample_size = 0, pairtest the full landscape.
**/


class cPopulationEventpairtest_landscape : public cPopulationEvent {
private:
  int sample_size;
public:
  cPopulationEventpairtest_landscape(const cString & in_args):
   cPopulationEvent("pairtest_landscape", in_args) {

    cString args(in_args);
    if (args == "") sample_size=0; else sample_size=args.PopWord().AsInt();
  }
///// pairtest_landscape /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    cAnalyzeUtil::PairTestLandscape(genome, population->GetEnvironment().GetInstSet(), sample_size, population->GetUpdate());
  }
};

///// test_dom /////

/**
**/


class cPopulationEventtest_dom : public cPopulationEvent {
private:
public:
  cPopulationEventtest_dom(const cString & in_args):
   cPopulationEvent("test_dom", in_args) {
 (void)in_args; }
///// test_dom /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    static ofstream fp("dom-test.dat");
    cAnalyzeUtil::TestGenome(genome, population->GetEnvironment().GetInstSet(), fp, population->GetUpdate());
  }
};

///// analyze_population /////

/**
**/


class cPopulationEventanalyze_population : public cPopulationEvent {
private:
  double sample_prob;
  int landscape;
  int save_genotype;
  cString filename;
public:
  cPopulationEventanalyze_population(const cString & in_args):
   cPopulationEvent("analyze_population", in_args) {

    cString args(in_args);
    if (args == "") sample_prob=1; else sample_prob=args.PopWord().AsDouble();
    if (args == "") landscape=0; else landscape=args.PopWord().AsInt();
    if (args == "") save_genotype=0; else save_genotype=args.PopWord().AsInt();
    if (args == "") filename=""; else filename=args.PopWord();
  }
///// analyze_population /////
  void Process(){
    static bool auto_filename = false;
    if( filename == "" )
      auto_filename = true;
    if ( auto_filename )
      filename.Set("population_info_%d.dat",population->GetUpdate());
    ofstream population_info(filename());
    cAnalyzeUtil::AnalyzePopulation(population, population_info, sample_prob,
    				landscape, save_genotype);
  }
};

///// print_detailed_fitness_data /////

/**
**/


class cPopulationEventprint_detailed_fitness_data : public cPopulationEvent {
private:
  int save_max_f_genotype;
  int print_fitness_histo;
  double hist_fmax;
  double hist_fstep;
  cString filename;
  cString filename2;
  cString filename3;
public:
  cPopulationEventprint_detailed_fitness_data(const cString & in_args):
   cPopulationEvent("print_detailed_fitness_data", in_args) {

    cString args(in_args);
    if (args == "") save_max_f_genotype=0; else save_max_f_genotype=args.PopWord().AsInt();
    if (args == "") print_fitness_histo=0; else print_fitness_histo=args.PopWord().AsInt();
    if (args == "") hist_fmax=1; else hist_fmax=args.PopWord().AsDouble();
    if (args == "") hist_fstep=0.1; else hist_fstep=args.PopWord().AsDouble();
    if (args == "") filename="fitness.dat"; else filename=args.PopWord();
    if (args == "") filename2="fitness_histos.dat"; else filename2=args.PopWord();
    if (args == "") filename3="fitness_histos_testCPU.dat"; else filename3=args.PopWord();
  }
///// print_detailed_fitness_data /////
  void Process(){
    static ofstream datafile(filename());
    static ofstream histofile;
    static ofstream histofile_testCPU;
    if (print_fitness_histo && !histofile.is_open()){
      histofile.open(filename2());
      histofile_testCPU.open(filename3());
    }
    cAnalyzeUtil::PrintDetailedFitnessData( population, datafile, histofile, histofile_testCPU, save_max_f_genotype, print_fitness_histo, hist_fmax, hist_fstep );
  }
};

///// print_genetic_distance_data /////

/**
**/


class cPopulationEventprint_genetic_distance_data : public cPopulationEvent {
private:
  cString creature_name;
  cString filename;
public:
  cPopulationEventprint_genetic_distance_data(const cString & in_args):
   cPopulationEvent("print_genetic_distance_data", in_args) {

    cString args(in_args);
    if (args == "") creature_name=""; else creature_name=args.PopWord();
    if (args == "") filename="genetic_distance.dat"; else filename=args.PopWord();
  }
///// print_genetic_distance_data /////
  void Process(){
    static ofstream popdump(filename());
    if( creature_name == "" || creature_name == "START_CREATURE" ){
      creature_name = cConfig::GetStartCreature(); }
    cAnalyzeUtil::PrintGeneticDistanceData( population, popdump, creature_name() );
  }
};

///// genetic_distance_pop_dump /////

/**
**/


class cPopulationEventgenetic_distance_pop_dump : public cPopulationEvent {
private:
  cString creature_name;
  cString filename;
  int save_genotype;
public:
  cPopulationEventgenetic_distance_pop_dump(const cString & in_args):
   cPopulationEvent("genetic_distance_pop_dump", in_args) {

    cString args(in_args);
    if (args == "") creature_name=""; else creature_name=args.PopWord();
    if (args == "") filename=""; else filename=args.PopWord();
    if (args == "") save_genotype=0; else save_genotype=args.PopWord().AsInt();
  }
///// genetic_distance_pop_dump /////
  void Process(){
    static bool auto_filename = false;
    if( creature_name == "" || creature_name == "START_CREATURE" ){
      creature_name = cConfig::GetStartCreature(); }
    if( filename == "" || filename == "AUTO" )
      auto_filename = true;
    if ( auto_filename )
      filename.Set("pop_dump_%d.dat",population->GetUpdate());
    ofstream popdump(filename());
    cAnalyzeUtil::GeneticDistancePopDump( population, popdump, creature_name(), save_genotype );
  }
};

///// task_snapshot /////

/**
**/


class cPopulationEventtask_snapshot : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventtask_snapshot(const cString & in_args):
   cPopulationEvent("task_snapshot", in_args) {

    cString args(in_args);
    if (args == "") filename=""; else filename=args.PopWord();
  }
///// task_snapshot /////
  void Process(){
    static bool auto_filename = false;
    if( filename == "" )
      auto_filename = true;
    if ( auto_filename )
      filename.Set("tasks_%d.dat",population->GetUpdate());
    ofstream snapshot_file(filename());
    cAnalyzeUtil::TaskSnapshot( population, snapshot_file );
  }
};

///// print_viable_tasks_data /////

/**
**/


class cPopulationEventprint_viable_tasks_data : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventprint_viable_tasks_data(const cString & in_args):
   cPopulationEvent("print_viable_tasks_data", in_args) {

    cString args(in_args);
    if (args == "") filename="viable_tasks.dat"; else filename=args.PopWord();
  }
///// print_viable_tasks_data /////
  void Process(){
    static ofstream datafile(filename());
    cAnalyzeUtil::PrintViableTasksData( population, datafile );
  }
};

///// apocalypse /////

/**
* Randomly removes a certain proportion of the population.
*
* Parameters:
* removal probability (double) default: 0.9
*   The probability with which a single organism is removed.
**/


class cPopulationEventapocalypse : public cPopulationEvent {
private:
  double kill_prob;
public:
  cPopulationEventapocalypse(const cString & in_args):
   cPopulationEvent("apocalypse", in_args) {

    cString args(in_args);
    if (args == "") kill_prob=.9; else kill_prob=args.PopWord().AsDouble();
  }
///// apocalypse /////
  void Process(){
    for (int i = 0; i < population->GetSize(); i++) {
      cPopulationCell & cell = population->GetCell(i);
      if (cell.IsOccupied() == false) continue;
      if (g_random.P(kill_prob))  population->KillOrganism(cell);
    }
  }
};

///// kill_rectangle /////

/**
* Kills all cell in a rectangle.
*
* Parameters:
* cell [X1][Y1][x2][Y2] (integer) default: 0
*   The start and stoping grid-points into which the organism should
be killed.
**/


class cPopulationEventkill_rectangle : public cPopulationEvent {
private:
  int cell_X1;
  int cell_Y1;
  int cell_X2;
  int cell_Y2;
public:
  cPopulationEventkill_rectangle(const cString & in_args):
   cPopulationEvent("kill_rectangle", in_args) {

    cString args(in_args);
    if (args == "") cell_X1=0; else cell_X1=args.PopWord().AsInt();
    if (args == "") cell_Y1=0; else cell_Y1=args.PopWord().AsInt();
    if (args == "") cell_X2=0; else cell_X2=args.PopWord().AsInt();
    if (args == "") cell_Y2=0; else cell_Y2=args.PopWord().AsInt();
  }
///// kill_rectangle /////
  void Process(){
    int i, j, loc;
    /* Be sure the user entered a valid range */
    if (cell_X1 < 0) {
      cell_X1 = 0;
    } else if (cell_X1 > population->GetWorldX() - 1) {
      cell_X1 = population->GetWorldX() - 1;
    }
    if (cell_X2 < 0) {
      cell_X2 = 0;
    } else if (cell_X2 > population->GetWorldX() - 1) {
      cell_X2 = population->GetWorldX() - 1;
    }
    if (cell_Y1 < 0) {
      cell_Y1 = 0;
    } else if (cell_Y1 > population->GetWorldY() - 1) {
      cell_Y1 = population->GetWorldY() - 1;
    }
    if (cell_Y2 < 0) {
      cell_Y2 = 0;
    } else if (cell_Y2 > population->GetWorldY() - 1) {
      cell_Y2 = population->GetWorldY() - 1;
    }
    /* Account for a rectangle that crosses over the Zero X or Y cell */
    if (cell_X2 < cell_X1) {
       cell_X2 = cell_X2 + population->GetWorldX();
    }
    if (cell_Y2 < cell_Y1) {
       cell_Y2 = cell_Y2 + population->GetWorldY();
    }
    for (i = cell_Y1; i <= cell_Y2; i++) {
       for (j = cell_X1; j <= cell_X2; j++) {
         loc = (i % population->GetWorldY()) * population->GetWorldX() +
               (j % population->GetWorldX());
         cPopulationCell & cell = population->GetCell(loc);
         if (cell.IsOccupied() == true) {
           population->KillOrganism(cell);
         }
       }
    }
    population->SetSyncEvents(true);
  }
};

///// rate_kill /////

/**
* Randomly removes a certain proportion of the population.
* In principle, this event does the same thing as the apocalypse event.
* However, instead of a probability, here one has to specify a rate. The
* rate has the same unit as fitness. So if the average fitness is 20000,
* than you remove 50% of the population on every update with a removal rate
* of 10000.
*
* Parameters:
* removal rate (double)
*   The rate at which organisms are removed.
**/


class cPopulationEventrate_kill : public cPopulationEvent {
private:
  double kill_rate;
public:
  cPopulationEventrate_kill(const cString & in_args):
   cPopulationEvent("rate_kill", in_args) {

    cString args(in_args);
    kill_rate = args.PopWord().AsDouble();
  }
///// rate_kill /////
  void Process(){
    const double ave = population->GetStats().SumMerit().Average();
    const double kill_prob = cConfig::GetAveTimeslice()*(kill_rate / ave);
    for (int i = 0; i < population->GetSize(); i++) {
      cPopulationCell & cell = population->GetCell(i);
      if (cell.IsOccupied() == false) continue;
      if (g_random.P(kill_prob))  population->KillOrganism(cell);
    }
  }
};

///// serial_transfer /////

/**
* This event does again the same thing as apocalypse. However, now
* the number of organisms to be retained can be specified
* exactly. Also, it is possible to specify whether any of these
* organisms may be dead or not.
*
* Parameters:
* transfer size (int) default: 1
*   The number of organisms to retain. If there are fewer living
*   organisms than the specified transfer size, then all living
*   organisms are retained.
* ignore deads (int) default: 1
*   When set to 1, only living organisms are retained. Otherwise,
*   every type of organism can be retained.
**/


class cPopulationEventserial_transfer : public cPopulationEvent {
private:
  int transfer_size;
  int ignore_deads;
public:
  cPopulationEventserial_transfer(const cString & in_args):
   cPopulationEvent("serial_transfer", in_args) {

    cString args(in_args);
    if (args == "") transfer_size=1; else transfer_size=args.PopWord().AsInt();
    if (args == "") ignore_deads=1; else ignore_deads=args.PopWord().AsInt();
  }
///// serial_transfer /////
  void Process(){
    population->SerialTransfer( transfer_size, ignore_deads );
  }
};

///// hillclimb /////

/**
* Does a hill climb with the dominant genotype.
**/


class cPopulationEventhillclimb : public cPopulationEvent {
private:
public:
  cPopulationEventhillclimb(const cString & in_args):
   cPopulationEvent("hillclimb", in_args) {
 (void)in_args; }
///// hillclimb /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    ofstream fp("hillclimb.dat");
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    landscape.HillClimb(fp);
  }
};

///// hillclimb_neut /////

/**
**/


class cPopulationEventhillclimb_neut : public cPopulationEvent {
private:
public:
  cPopulationEventhillclimb_neut(const cString & in_args):
   cPopulationEvent("hillclimb_neut", in_args) {
 (void)in_args; }
///// hillclimb_neut /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    ofstream fp("hillclimb.dat");
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    landscape.HillClimb_Neut(fp);
  }
};

///// hillclimb_rand /////

/**
**/


class cPopulationEventhillclimb_rand : public cPopulationEvent {
private:
public:
  cPopulationEventhillclimb_rand(const cString & in_args):
   cPopulationEvent("hillclimb_rand", in_args) {
 (void)in_args; }
///// hillclimb_rand /////
  void Process(){
    cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
    ofstream fp("hillclimb.dat");
    cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
    landscape.HillClimb_Rand(fp);
  }
};

///// calc_consensus /////

/**
* Calculates the consensus sequence.
*
* Parameters:
* lines saved (integer) default: 0
*    ???
**/


class cPopulationEventcalc_consensus : public cPopulationEvent {
private:
  int lines_saved;
public:
  cPopulationEventcalc_consensus(const cString & in_args):
   cPopulationEvent("calc_consensus", in_args) {

    cString args(in_args);
    if (args == "") lines_saved=0; else lines_saved=args.PopWord().AsInt();
  }
///// calc_consensus /////
  void Process(){
    cAnalyzeUtil::CalcConsensus(population, lines_saved);
  }
};

///// test_size_change_robustness /////

/**
**/


class cPopulationEventtest_size_change_robustness : public cPopulationEvent {
private:
  int num_trials;
  cString filename;
public:
  cPopulationEventtest_size_change_robustness(const cString & in_args):
   cPopulationEvent("test_size_change_robustness", in_args) {

    cString args(in_args);
    if (args == "") num_trials=100; else num_trials=args.PopWord().AsInt();
    if (args == "") filename="size_change.dat"; else filename=args.PopWord();
  }
///// test_size_change_robustness /////
  void Process(){
    ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
    cAnalyzeUtil::TestInsSizeChangeRobustness(fp,
    		population->GetEnvironment().GetInstSet(),
    		population->GetGenebank().GetBestGenotype()->GetGenome(),
    		num_trials, population->GetUpdate());
  }
};

///// test_threads /////

/**
**/


class cPopulationEventtest_threads : public cPopulationEvent {
private:
public:
  cPopulationEventtest_threads(const cString & in_args):
   cPopulationEvent("test_threads", in_args) {
 (void)in_args; }
///// test_threads /////
  void Process(){
    cTestCPU::TestThreads(population->GetGenebank().GetBestGenotype()->GetGenome());
  }
};

///// print_threads /////

/**
**/


class cPopulationEventprint_threads : public cPopulationEvent {
private:
public:
  cPopulationEventprint_threads(const cString & in_args):
   cPopulationEvent("print_threads", in_args) {
 (void)in_args; }
///// print_threads /////
  void Process(){
    cTestCPU::PrintThreads( population->GetGenebank().GetBestGenotype()->GetGenome() );
  }
};

///// dump_fitness_grid /////

/**
* Writes out all fitness values of the organisms currently in the
* population.
*
* The output file is called "fgrid.*.out", where '*' is replaced by the
* number of the current update.
**/


class cPopulationEventdump_fitness_grid : public cPopulationEvent {
private:
public:
  cPopulationEventdump_fitness_grid(const cString & in_args):
   cPopulationEvent("dump_fitness_grid", in_args) {
 (void)in_args; }
///// dump_fitness_grid /////
  void Process(){
    cString filename;
    filename.Set("fgrid.%05d.out", population->GetUpdate());
    ofstream fp(filename());
    for (int i = 0; i < population->GetWorldX(); i++) {
      for (int j = 0; j < population->GetWorldY(); j++) {
        cPopulationCell & cell = population->GetCell(j*population->GetWorldX()+i);
        double fitness = (cell.IsOccupied()) ?
    	 cell.GetOrganism()->GetGenotype()->GetFitness() : 0.0;
        fp << fitness << " ";
      }
      fp << endl;
    }
  }
};

///// dump_genotype_grid /////

/**
* Writes out all genotype id values of the organisms currently in the
* population.
*
* The output file is called "idgrid.*.out", where '*' is replaced by the
* number of the current update.
**/


class cPopulationEventdump_genotype_grid : public cPopulationEvent {
private:
public:
  cPopulationEventdump_genotype_grid(const cString & in_args):
   cPopulationEvent("dump_genotype_grid", in_args) {
 (void)in_args; }
///// dump_genotype_grid /////
  void Process(){
    cString filename;
    filename.Set("idgrid.%05d.out", population->GetUpdate());
    ofstream fp(filename());
    for (int i = 0; i < population->GetWorldX(); i++) {
      for (int j = 0; j < population->GetWorldY(); j++) {
        cPopulationCell & cell = population->GetCell(j*population->GetWorldX()+i);
        int id = (cell.IsOccupied()) ?
    	 cell.GetOrganism()->GetGenotype()->GetID() : -1;
        fp << id << " ";
      }
      fp << endl;
    }
  }
};

///// print_tree_depths /////

/**
* Reconstruction of phylogenetic trees.
**/


class cPopulationEventprint_tree_depths : public cPopulationEvent {
private:
  cString filename;
public:
  cPopulationEventprint_tree_depths(const cString & in_args):
   cPopulationEvent("print_tree_depths", in_args) {

    cString args(in_args);
    if (args == "") filename=""; else filename=args.PopWord();
  }
///// print_tree_depths /////
  void Process(){
    if (filename == "") filename.Set("tree_depth.%d.dat", population->GetUpdate());
    ofstream fp(filename);
    cAnalyzeUtil::PrintTreeDepths(population, fp);
  }
};

///// sever_grid_col /////

/**
* Remove the connections between cells along a column in an avida grid.
* Arguments:
*  col_id:  indicats the number of columns to the left of the cut.
*           default (or -1) = cut population in half
*  min_row: First row to start cutting from
*           default = 0
*  max_row: Last row to cut to
*           default (or -1) = last row in population.
**/


class cPopulationEventsever_grid_col : public cPopulationEvent {
private:
  int col_id;
  int min_row;
  int max_row;
public:
  cPopulationEventsever_grid_col(const cString & in_args):
   cPopulationEvent("sever_grid_col", in_args) {

    cString args(in_args);
    if (args == "") col_id=-1; else col_id=args.PopWord().AsInt();
    if (args == "") min_row=0; else min_row=args.PopWord().AsInt();
    if (args == "") max_row=-1; else max_row=args.PopWord().AsInt();
  }
///// sever_grid_col /////
  void Process(){
    const int world_x = population->GetWorldX();
    const int world_y = population->GetWorldY();
    if (col_id == -1) col_id = world_x / 2;
    if (max_row == -1) max_row = world_y;
    if (col_id < 0 || col_id >= world_x) {
      cerr << "Event Error: Column ID " << col_id
           << " out of range for sever_grid_col" << endl;
      return;
    }
    // Loop through all of the rows and make the cut on each...
    for (int row_id = min_row; row_id < max_row; row_id++) {
      int idA = row_id * world_x + col_id;
      int idB  = Neighbor(idA, world_x, world_y, -1,  0);
      int idA0 = Neighbor(idA, world_x, world_y,  0, -1);
      int idA1 = Neighbor(idA, world_x, world_y,  0,  1);
      int idB0 = Neighbor(idA, world_x, world_y, -1, -1);
      int idB1 = Neighbor(idA, world_x, world_y, -1,  1);
      cPopulationCell & cellA = population->GetCell(idA);
      cPopulationCell & cellB = population->GetCell(idB);
      tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
      tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
      cellA_list.Remove(&population->GetCell(idB));
      cellA_list.Remove(&population->GetCell(idB0));
      cellA_list.Remove(&population->GetCell(idB1));
      cellB_list.Remove(&population->GetCell(idA));
      cellB_list.Remove(&population->GetCell(idA0));
      cellB_list.Remove(&population->GetCell(idA1));
    }
  }
};

///// connect_cells /////

/**
* Connects a pair of specified cells.
* Arguments:
*  cellA_x, cellA_y, cellB_x, cellB_y
**/


class cPopulationEventconnect_cells : public cPopulationEvent {
private:
  int cellA_x;
  int cellA_y;
  int cellB_x;
  int cellB_y;
public:
  cPopulationEventconnect_cells(const cString & in_args):
   cPopulationEvent("connect_cells", in_args) {

    cString args(in_args);
    cellA_x = args.PopWord().AsInt();
    cellA_y = args.PopWord().AsInt();
    cellB_x = args.PopWord().AsInt();
    cellB_y = args.PopWord().AsInt();
  }
///// connect_cells /////
  void Process(){
    const int world_x = population->GetWorldX();
    const int world_y = population->GetWorldY();
    if (cellA_x < 0 || cellA_x >= world_x ||
        cellA_y < 0 || cellA_y >= world_y ||
        cellB_x < 0 || cellB_x >= world_x ||
        cellB_y < 0 || cellB_y >= world_y) {
      cerr << "Event 'connect_cells' cell out of range." << endl;
      return;
    }
    int idA = cellA_y * world_x + cellA_x;
    int idB = cellB_y * world_x + cellB_x;
    cPopulationCell & cellA = population->GetCell(idA);
    cPopulationCell & cellB = population->GetCell(idB);
    tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
    tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
    cellA_list.PushRear(&cellB);
    cellB_list.PushRear(&cellA);
  }
};

///// disconnect_cells /////

/**
* Connects a pair of specified cells.
* Arguments:
*  cellA_x, cellA_y, cellB_x, cellB_y
**/


class cPopulationEventdisconnect_cells : public cPopulationEvent {
private:
  int cellA_x;
  int cellA_y;
  int cellB_x;
  int cellB_y;
public:
  cPopulationEventdisconnect_cells(const cString & in_args):
   cPopulationEvent("disconnect_cells", in_args) {

    cString args(in_args);
    cellA_x = args.PopWord().AsInt();
    cellA_y = args.PopWord().AsInt();
    cellB_x = args.PopWord().AsInt();
    cellB_y = args.PopWord().AsInt();
  }
///// disconnect_cells /////
  void Process(){
    const int world_x = population->GetWorldX();
    const int world_y = population->GetWorldY();
    if (cellA_x < 0 || cellA_x >= world_x ||
        cellA_y < 0 || cellA_y >= world_y ||
        cellB_x < 0 || cellB_x >= world_x ||
        cellB_y < 0 || cellB_y >= world_y) {
      cerr << "Event 'connect_cells' cell out of range." << endl;
      return;
    }
    int idA = cellA_y * world_x + cellA_x;
    int idB = cellB_y * world_x + cellB_x;
    cPopulationCell & cellA = population->GetCell(idA);
    cPopulationCell & cellB = population->GetCell(idB);
    tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
    tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
    cellA_list.Remove(&cellB);
    cellB_list.Remove(&cellA);
  }
};

///// inject_resource /////

/**
* Inject (add) a specified amount of a specified resource.
**/


class cPopulationEventinject_resource : public cPopulationEvent {
private:
  cString res_name;
  double res_count;
public:
  cPopulationEventinject_resource(const cString & in_args):
   cPopulationEvent("inject_resource", in_args) {

    cString args(in_args);
    res_name = args.PopWord();
    res_count = args.PopWord().AsDouble();
  }
///// inject_resource /////
  void Process(){
    cResourceLib & res_lib = population->GetEnvironment().GetResourceLib();
    int res_id = res_lib.GetResource(res_name)->GetID();
    population->UpdateResource(res_id, res_count);
  }
};

///// set_resource /////

/**
* Set the resource amount to a specific level
**/


class cPopulationEventset_resource : public cPopulationEvent {
private:
  cString res_name;
  double res_count;
public:
  cPopulationEventset_resource(const cString & in_args):
   cPopulationEvent("set_resource", in_args) {

    cString args(in_args);
    res_name = args.PopWord();
    res_count = args.PopWord().AsDouble();
  }
///// set_resource /////
  void Process(){
    cResourceLib & res_lib = population->GetEnvironment().GetResourceLib();
    int res_id = res_lib.GetResource(res_name)->GetID();
    population->SetResource(res_id, res_count);
  }
};

