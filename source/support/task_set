# Should be input tasks, then output tasks (otherwise, they will get reordered)
# Bonus types can be:
#	*  ->  merit *= bonus
#	+  ->  merit += bonus
#	^  ->  merit = pow(merit,bonus)
#
# Use "+ 0" for no bonus
#
# Last bonus type can be "d" which will be a "diminish value"
# For example, "* 1.8  * 1.7  d .5" will give bonuses of:
#  1st time: merit *= 1.8
#  2rd time: merit *= 1.8 * 1.7
#  3rd time: merit *= 1.8 * (1 + (.7 * .5))
#  4th time: merit *= 1.8 * (1 + (.7 * .5*.5))
#  5th time: merit *= 1.8 * (1 + (.7 * .5.*.5*.5))
#
# Task	type bonus type bonus ...	# Meaning & Difficulty

# IO - Depends only on executing the instructions (no logic)
get	-	* 1.05	* 1.05	* 1.05	+ 0
put	-	* 1.05	* 1.05	* 1.05	+ 0

logic	1a	* 1.05	* 1.05	+ 0	# Echo
logic	1b	* 1.1	* 1.05	+ 0	# Not

logic	2a	* 1.2	* 1.1	+ 0	# A and B	- 2 nands
logic	2b	* 1.25	* 1.1	+ 0	# A or B	- 3 nands
logic	2c	* 1.2	* 1.1	+ 0	# A or ~B	- 2 nands
logic	2d	* 1.25	* 1.1	+ 0	# A and ~B	- 3 nands
logic	2e	* 1.3	* 1.1	+ 0	# A nor B	- 4 nands
logic	2f	* 1.15	* 1.1	+ 0	# A nand B	- 1 nand
logic	2g	* 1.5	* 1.1	+ 0	# A xor B	- 5 nands
logic	2h	* 1.5	* 1.1	+ 0	# A equ B	- 5 nands

logic	3a	* 1.5	* 1.1	+ 0	# A and B and C
logic	3b	* 1.5	* 1.1	+ 0	# A and B and ~C
logic	3c	* 1.5	* 1.1	+ 0	# A and ~B and ~C
logic	3d	* 1.5	* 1.1	+ 0	# ~A and ~B and ~C
logic	3e	* 1.5	* 1.1	+ 0	# A and (B xor C)
logic	3f	* 1.5	* 1.1	+ 0	# A & (B | C)
logic	3g	* 1.5	* 1.1	+ 0	# A + B + C = 2
logic	3h	* 1.5	* 1.1	+ 0	# A + B + C >= 2
logic	3i	* 1.5	* 1.1	+ 0	# A & ~(B xor C)
logic	3j	* 1.5	* 1.1	+ 0	# A xor (B & C)
logic	3k	* 1.5	* 1.1	+ 0	# A | (B & C)
logic	3l	* 1.5	* 1.1	+ 0	# A & (B | ~C)
logic	3m	* 1.5	* 1.1	+ 0	# (A & ~B) | (~A & B & C)
logic	3n	* 1.5	* 1.1	+ 0	# (A & ~B) | (B & C)
logic	3o	* 1.5	* 1.1	+ 0	# A & (B nand C)
logic	3p	* 1.5	* 1.1	+ 0	# A xor (B & C)
logic	3q	* 1.5	* 1.1	+ 0	# A | (B & C)
logic	3r	* 1.5	* 1.1	+ 0	# (A xor B) & ~C
logic	3s	* 1.5	* 1.1	+ 0	# ~A & ( B xor C) ) | (A & B & C)
logic	3t	* 1.5	* 1.1	+ 0	# (A & ~B) | (~A & B & ~C)
logic	3u	* 1.5	* 1.1	+ 0	# A & (B | ~C) | (~A & ~B & C)
logic	3v	* 1.5	* 1.1	+ 0	# (A xor B) | (A & C)
logic	3w	* 1.5	* 1.1	+ 0	# (A nor B) nor C
logic	3x	* 1.5	* 1.1	+ 0	# (~A & (B | C)) | (B & C)
logic	3y	* 1.5	* 1.1	+ 0	# (~A & B) | (~A & C) | (B & ~C)
logic	3z	* 1.5	* 1.1	+ 0	# A | (B & ~C)
logic	3aa	* 1.5	* 1.1	+ 0	# (A & ~B) | (A & ~C) | (~A & B)
logic	3ab	* 1.5	* 1.1	+ 0	# A + B + C = 1
logic	3ac	* 1.5	* 1.1	+ 0	# A xor B xor C
logic	3ad	* 1.5	* 1.1	+ 0	# (A & ~C) | (B & ~C) | (~A & ~B & C)
logic	3ae	* 1.5	* 1.1	+ 0	# ???
logic	3af	* 1.5	* 1.1	+ 0	# ???
logic	3ag	* 1.5	* 1.1	+ 0	# A | (B xor C)
logic	3ah	* 1.5	* 1.1	+ 0	# ~( (A & B & C) | (~A & ~B & ~C) )
logic	3ai	* 1.5	* 1.1	+ 0	# A or B or C
logic	3aj	* 1.5	* 1.1	+ 0	# (A & B & C) | (~A & ~B & ~C)
logic	3ak	* 1.5	* 1.1	+ 0	# A nor (B xor C)
logic	3al	* 1.5	* 1.1	+ 0	# ???
logic	3am	* 1.5	* 1.1	+ 0	# ???
logic	3an	* 1.5	* 1.1	+ 0	# (C & (A | B)) | (~A & ~B & ~C)
logic	3ao	* 1.5	* 1.1	+ 0	# A xor ~(B xor C)
logic	3ap	* 1.5	* 1.1	+ 0	# A + B + C != 1
logic	3aq	* 1.5	* 1.1	+ 0	# (~A & ~B) | (A & B & C)
logic	3ar	* 1.5	* 1.1	+ 0	# (A xor B) nor (A & C)
logic	3as	* 1.5	* 1.1	+ 0	# ~A & (B | ~C)
logic	3at	* 1.5	* 1.1	+ 0	# (A & ~B) | (A & C) | (~B & ~C)
logic	3au	* 1.5	* 1.1	+ 0	# ???
logic	3av	* 1.5	* 1.1	+ 0	# ???
logic	3aw	* 1.5	* 1.1	+ 0	# ???
logic	3ax	* 1.5	* 1.1	+ 0	# A | (B nor C)
logic	3ay	* 1.5	* 1.1	+ 0	# (~A & (~B | C)) | (A & (B xor C))
logic	3az	* 1.5	* 1.1	+ 0	# A | ~(B xor C)
logic	3ba	* 1.5	* 1.1	+ 0	# A nor (B & C)
logic	3bb	* 1.5	* 1.1	+ 0	# A equ (B & C)
logic	3bc	* 1.5	* 1.1	+ 0	# (A & ~B) nor (B & C)
logic	3bd	* 1.5	* 1.1	+ 0	# (A & ~B) nor (~A & B & C)
logic	3be	* 1.5	* 1.1	+ 0	# A nor (B & C)
logic	3bf	* 1.5	* 1.1	+ 0	# A equ (B & C)
logic	3bg	* 1.5	* 1.1	+ 0	# A nand B nand C
logic	3bh	* 1.5	* 1.1	+ 0	# ~A | (B & ~C)
logic	3bi	* 1.5	* 1.1	+ 0	# A nand ~(B xor C)
logic	3bj	* 1.5	* 1.1	+ 0	# ~A | B | C
logic	3bk	* 1.5	* 1.1	+ 0	# A + B + C <= 1
logic	3bl	* 1.5	* 1.1	+ 0	# A + B + C != 2
logic	3bm	* 1.5	* 1.1	+ 0	# A nand (B | C)
logic	3bn	* 1.5	* 1.1	+ 0	# A nand (B xor C)
logic	3bo	* 1.5	* 1.1	+ 0	# ~A | ~B | C
logic	3bp	* 1.5	* 1.1	+ 0	# ~A | ~B | ~C
