# Should be input tasks, then output tasks (otherwise, they will get reordered)
# Bonus types can be:
#	*  ->  merit *= bonus
#	+  ->  merit += bonus
#	^  ->  merit = pow(merit,bonus) 
#
# Use "+ 0" for no bonus
#
# Task	type bonus type bonus ...	# Meaning & Difficulty

# IO - Depends only on executing the instructions (no logic)
get	-	* 1.05	* 1.05	* 1.05	+ 0
put	-	* 1.05	* 1.05	* 1.05	+ 0

# Task (any last output is function of _last_ input)
#echo	-	* 1.25 	* 1.25 	* 1.25	+ 0	# A
#not	-	* 1.5 	* 1.25 	* 1.25	+ 0	# ~A

# tasks (any last output is function of _last_ two inputs)
#ggp	-	* 1.25	* 1.25	* 1.25	+ 0
#nand	-	* 1.5	* 1.25	* 1.25	+ 0	# ~(A and B)	- 1 nand
#or_n	-	* 2	* 1.25	* 1.25	+ 0	#  A or ~B	- 2 nands
#and	-	* 2	* 1.25	* 1.25 	+ 0	#  A and B	- 2 nands
#or	-	* 3	* 1.25	* 1.25	+ 0	#  A or B	- 3 nands
#and_n	-	* 3	* 1.25	* 1.25	+ 0	#  A and ~B	- 3 nands
#nor	-	* 5	* 1.25	* 1.25	+ 0	# ~(A or B)	- 4 nands
#xor	-	* 9	* 1.25	* 1.25	+ 0	#  A xor B	- 5 nands
#equ	-	* 9	* 1.25	* 1.25	+ 0	# ~(A xor B)	- 5 nands

# Logic!!!!
# logic	0a	* 1.05	* 1.05	* 1.05	* 1.05	+ 0	# Zero
# logic	0b	* 1.05	* 1.05	* 1.05	* 1.05	+ 0	# One

logic	1a	* 1.05	* 1.05	+ 0	# Echo
logic	1b	* 1.1	* 1.05	+ 0	# Not

logic	2a	* 1.2	* 1.1	+ 0	# A and B
logic	2b	* 1.25	* 1.1	+ 0	# A or B
logic	2c	* 1.2	* 1.1	+ 0	# A or ~B
logic	2d	* 1.25	* 1.1	+ 0	# A and ~B
logic	2e	* 1.3	* 1.1	+ 0	# A nor B
logic	2f	* 1.15	* 1.1	+ 0	# A nand B
logic	2g	* 1.5	* 1.1	+ 0	# A xor B
logic	2h	* 1.5	* 1.1	+ 0	# A equ B

logic	3a	* 1.5	* 1.1	+ 0	# A and B and C
logic	3b	* 1.5	* 1.1	+ 0	# A and B and ~C
logic	3c	* 1.5	* 1.1	+ 0	# A and ~B and ~C
logic	3d	* 1.5	* 1.1	+ 0	# ~A and ~B and ~C
logic	3e	* 1.5	* 1.1	+ 0	# A and (B xor C)
logic	3f	* 1.5	* 1.1	+ 0	# A & (B | C)
logic	3g	* 1.5	* 1.1	+ 0	# A + B + C = 2
logic	3h	* 1.5	* 1.1	+ 0	# A + B + C >= 2
logic	3i	* 1.5	* 1.1	+ 0	# A & ~(B xor C)
logic	3j	* 1.5	* 1.1	+ 0	# A xor (B & C)
logic	3k	* 1.5	* 1.1	+ 0	# A | (B & C)
logic	3l	* 1.5	* 1.1	+ 0	# A & (B | ~C)
logic	3m	* 1.5	* 1.1	+ 0	# (A & ~B) | (~A & B & C)
logic	3n	* 1.5	* 1.1	+ 0	# (A & ~B) | (B & C)
logic	3o	* 1.5	* 1.1	+ 0	# A & (B nand C) 
logic	3p	* 1.5	* 1.1	+ 0	# A xor (B & C)
logic	3q	* 1.5	* 1.1	+ 0	# A | (B & C)
logic	3r	* 1.5	* 1.1	+ 0	# (A xor B) & ~C
logic	3s	* 1.5	* 1.1	+ 0	# ~A & ( B xor C) ) | (A & B & C)
logic	3t	* 1.5	* 1.1	+ 0	# (A & ~B) | (~A & B & ~C) 
logic	3u	* 1.5	* 1.1	+ 0	# A & (B | ~C) | (~A & ~B & C)
logic	3v	* 1.5	* 1.1	+ 0	# (A xor B) | (A & C)
logic	3w	* 1.5	* 1.1	+ 0	# (A nor B) nor C
logic	3x	* 1.5	* 1.1	+ 0	# (~A & (B | C)) | (B & C)
logic	3y	* 1.5	* 1.1	+ 0	# (~A & B) | (~A & C) | (B & ~C)
logic	3z	* 1.5	* 1.1	+ 0	# A | (B & ~C)
logic	3aa	* 1.5	* 1.1	+ 0	# (A & ~B) | (A & ~C) | (~A & B)
logic	3ab	* 1.5	* 1.1	+ 0	# A + B + C = 1
logic	3ac	* 1.5	* 1.1	+ 0	# A xor B xor C
logic	3ad	* 1.5	* 1.1	+ 0	# (A & ~C) | (B & ~C) | (~A & ~B & C)
logic	3ae	* 1.5	* 1.1	+ 0	# ???
logic	3af	* 1.5	* 1.1	+ 0	# ???
logic	3ag	* 1.5	* 1.1	+ 0	# A | (B xor C)
logic	3ah	* 1.5	* 1.1	+ 0	# ~( (A & B & C) | (~A & ~B & ~C) )
logic	3ai	* 1.5	* 1.1	+ 0	# A or B or C
logic	3aj	* 1.5	* 1.1	+ 0	# (A & B & C) | (~A & ~B & ~C)
logic	3ak	* 1.5	* 1.1	+ 0	# A nor (B xor C)
logic	3al	* 1.5	* 1.1	+ 0	# ???
logic	3am	* 1.5	* 1.1	+ 0	# ???
logic	3an	* 1.5	* 1.1	+ 0	# (C & (A | B)) | (~A & ~B & ~C)
logic	3ao	* 1.5	* 1.1	+ 0	# A xor ~(B xor C)
logic	3ap	* 1.5	* 1.1	+ 0	# A + B + C != 1
logic	3aq	* 1.5	* 1.1	+ 0	# (~A & ~B) | (A & B & C)
logic	3ar	* 1.5	* 1.1	+ 0	# (A xor B) nor (A & C)
logic	3as	* 1.5	* 1.1	+ 0	# ~A & (B | ~C)
logic	3at	* 1.5	* 1.1	+ 0	# (A & ~B) | (A & C) | (~B & ~C)
logic	3au	* 1.5	* 1.1	+ 0	# ???
logic	3av	* 1.5	* 1.1	+ 0	# ???
logic	3aw	* 1.5	* 1.1	+ 0	# ???
logic	3ax	* 1.5	* 1.1	+ 0	# A | (B nor C)
logic	3ay	* 1.5	* 1.1	+ 0	# (~A & (~B | C)) | (A & (B xor C))
logic	3az	* 1.5	* 1.1	+ 0	# A | ~(B xor C)
logic	3ba	* 1.5	* 1.1	+ 0	# A nor (B & C)
logic	3bb	* 1.5	* 1.1	+ 0	# A equ (B & C)
logic	3bc	* 1.5	* 1.1	+ 0	# (A & ~B) nor (B & C)
logic	3bd	* 1.5	* 1.1	+ 0	# (A & ~B) nor (~A & B & C)
logic	3be	* 1.5	* 1.1	+ 0	# A nor (B & C)
logic	3bf	* 1.5	* 1.1	+ 0	# A equ (B & C)
logic	3bg	* 1.5	* 1.1	+ 0	# A nand B nand C
logic	3bh	* 1.5	* 1.1	+ 0	# ~A | (B & ~C)
logic	3bi	* 1.5	* 1.1	+ 0	# A nand ~(B xor C)
logic	3bj	* 1.5	* 1.1	+ 0	# ~A | B | C
logic	3bk	* 1.5	* 1.1	+ 0	# A + B + C <= 1
logic	3bl	* 1.5	* 1.1	+ 0	# A + B + C != 2
logic	3bm	* 1.5	* 1.1	+ 0	# A nand (B | C)
logic	3bn	* 1.5	* 1.1	+ 0	# A nand (B xor C)
logic	3bo	* 1.5	* 1.1	+ 0	# ~A | ~B | C
logic	3bp	* 1.5	* 1.1	+ 0	# ~A | ~B | ~C
